
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>数据结构与算法--B树（B-树） | Molu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1 引言  数据库的增删改查等操作是开发过程中最为常见也是尤为重要的，尤其是现在大数据的兴起，导致数据存储量急剧增加，提升数据的操作效率就变得尤为关键。大部分数据库的索引都采用树的结构存储，这是因为树的查询效率相对较高，且保持有序。  对于二叉搜索树的时间复杂度是O(logN)，在算法以及逻辑上来分析，二叉搜索树的查找速度以及数据比较次数都是较小的。但是我们不得不考虑一个新的问题。数据量是远大于内">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法--B树（B-树）">
<meta property="og:url" content="http://example.com/2019/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-B%E6%A0%91%EF%BC%88B-%E6%A0%91%EF%BC%89/index.html">
<meta property="og:site_name" content="Molu">
<meta property="og:description" content="1 引言  数据库的增删改查等操作是开发过程中最为常见也是尤为重要的，尤其是现在大数据的兴起，导致数据存储量急剧增加，提升数据的操作效率就变得尤为关键。大部分数据库的索引都采用树的结构存储，这是因为树的查询效率相对较高，且保持有序。  对于二叉搜索树的时间复杂度是O(logN)，在算法以及逻辑上来分析，二叉搜索树的查找速度以及数据比较次数都是较小的。但是我们不得不考虑一个新的问题。数据量是远大于内">
<meta property="og:locale">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/d8e53bed63242e2f5a09d32c6c1df298.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/2955b897ebf9654beef84f1907f64f26.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/dc033d4156cfa7da62d0c2f5a354238d.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/b5a9e1ada99f5ee6d90254ec2972514c.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/0b2fb4783a1f3a3dde1f3066dc234ba2.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/69d81bce093055474a03f15d3a42dcfb.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/052d77ab4c66bd2386c298bd2ff723cf.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/726b4e497e7e950fa0a94e336e3e78ff.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/366534f447bf277b2936bea5c64e7262.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/f9c8f652f7f932620142f1489702967d.png">
<meta property="article:published_time" content="2019-11-04T10:25:11.000Z">
<meta property="article:modified_time" content="2019-11-04T10:30:12.000Z">
<meta property="article:author" content="Rick Smith">
<meta property="article:tag" content="树论和图论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.xiaozhuanlan.com/photo/2019/d8e53bed63242e2f5a09d32c6c1df298.png">
  
  
    <link rel="icon" href="/favicon.png">
  
  
	<!-- If needed, replace your own web font service -->
  <link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,700|Inconsolata|Oswald" rel="stylesheet" />

  
   
  
<link rel="stylesheet" href="/icomoon/style.css">

  
<link rel="stylesheet" href="/style.css">


<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div class="site-wrapper is_post_page">
    <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<script>document.getElementById("loading-bar").style.width="20%";</script>


<header id="header" class="site-header clearfix">

  <a class="logo square clearfix" href="/">
    <!-- 
      Replace with your own size name, for example:
      <span class="b">A</span>
      <span class="w">B</span>
      <span class="b">C</span>
     -->
     <span class="b">M</span>
     <span class="b">O</span>
     <span class="b">L</span>
     <span class="w">U</span>
     <span class="w">-</span>
     <span class="b">Q</span>
     <span class="b">w</span>
     <span class="b">Q</span>
  </a>
  <a class="me square site-nav-switch clearfix">
    <span class="b">
    	<span class="icon icon-menu"></span>
    </span>
  </a>

</header>

    <script>document.getElementById("loading-bar").style.width="40%";</script>
    <main id="main" class="clearfix">
      <article id="post-数据结构与算法-B树（B-树）"
  class="article white-box article-type-post"
  itemscope itemprop="blogPost">

  <header class="article-header">
    <h1 class="article-title" itemprop="name">
      数据结构与算法--B树（B-树）
    </h1>
    <div class="article-meta">
      Posted on 
      <time class="article-time" datetime="2019-11-04T10:25:11.000Z" itemprop="datePublished">
        Nov 4, 2019
      </time>
    </div>
  </header>

  <div class="article-entry" itemprop="articleBody">
    <h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>  数据库的增删改查等操作是开发过程中最为常见也是尤为重要的，尤其是现在大数据的兴起，导致数据存储量急剧增加，提升数据的操作效率就变得尤为关键。大部分数据库的索引都采用树的结构存储，这是因为树的查询效率相对较高，且保持有序。<br>  对于二叉搜索树的时间复杂度是O(logN)，在算法以及逻辑上来分析，二叉搜索树的查找速度以及数据比较次数都是较小的。但是我们不得不考虑一个新的问题。数据量是远大于内存大小的，那我们在查找数据时并不能将全部数据同时加载至内存。既然不能全部加载至内存中就只能逐步的去加载磁盘中某个页，简而言之就是逐一的去加载磁盘，加数据分块的加载至内存进行查找与比较。<br>  例如：在图1.1所示的树中查找10，树中的每个节点代表一个磁盘页。每次访问一个新节点代表一次磁盘IO。<br><img src="https://images.xiaozhuanlan.com/photo/2019/d8e53bed63242e2f5a09d32c6c1df298.png" alt="img"><br><img src="https://images.xiaozhuanlan.com/photo/2019/2955b897ebf9654beef84f1907f64f26.png" alt="图1.1"></p>
<p>图1.1</p>
<p>  通过查找过程可以看出，磁盘IO次数与树的高度相关，在最坏情况下，磁盘IO次数等于树的高度。由于磁盘IO过程是相对耗时效率较低的，因此，在设计数据存储结构时需要降低树的高度，即将一棵“瘦高”的树变得“矮胖”。<br>  当数据数目相同，在保持有序前提下，降低树高度，只需将节点中存储的key值增加，即二叉搜索树中每个节点只有一个key，现将一个节点中存储多个key，得到的树即为B树。</p>
<h1 id="2-定义"><a href="#2-定义" class="headerlink" title="2 定义"></a>2 定义</h1><p>  <strong>B树</strong>也称B-树,B-树直接读作B树，不能因为有“-”号就读作B减树，它是一颗多路平衡查找树。我们描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是我们常见的二叉搜索树，m为3时是2-3树。<br>  <strong>一颗m阶的B树定义如下：</strong></p>
<blockquote>
<p>（1）每个结点最多有m-1个关键字。<br>（2）根结点最少可以只有1个关键字。<br>（3）非根结点至少有Math.ceil(m/2)-1个关键字。Math.ceil(m/2)含义是向上取整。例如Math.ceil(4.5) = 5。<br>（4）每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。<br>（5）所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。</p>
</blockquote>
<h1 id="3-查找"><a href="#3-查找" class="headerlink" title="3 查找"></a>3 查找</h1><p>  B-树的查找其实是对二叉搜索树查找的扩展， 与二叉搜索树不同的地方是，B-树中每个节点有不止一棵子树。在B-树中查找某个结点时，需要先判断要查找的结点在哪棵子树上，然后在结点中逐个查找目标结点。B树的查找过程相对简单，与二叉搜索树类似，因此不再赘述。</p>
<h1 id="4-插入"><a href="#4-插入" class="headerlink" title="4 插入"></a>4 插入</h1><p>  B树的插入操作是指在树种插入一条新记录，即（key, value）的键值对。如果B树中已存在需要插入的键值对，则用需要插入的value替换旧的value。若B树不存在这个key，则一定是在叶子结点中进行插入操作。</p>
<h2 id="4-1-插入流程"><a href="#4-1-插入流程" class="headerlink" title="4.1 插入流程"></a>4.1 插入流程</h2><p><strong>B树的插入流程如下：</strong><br>  （1）根据要插入的key的值，对B树执行查找操作，查找到待插入数据的当前节点位置。<br>  （2）判断当前结点key的个数是否小于等于m-1，若满足，则结束直接插入数据，否则，进行第（3）步。<br>  （3）以结点中间的key为中心分裂成左右两部分，然后将这个中间的key插入到父结点中，这个key的左子树指向分裂后的左半部分，这个key的右子支指向分裂后的右半部分，然后将当前结点指向父结点，继续进行第（3）步。</p>
<h2 id="4-2-实例图解"><a href="#4-2-实例图解" class="headerlink" title="4.2 实例图解"></a>4.2 实例图解</h2><p>  下面以5阶B树为例，介绍B树的插入操作，在5阶B树中，结点最多有4个key,最少有2个key。</p>
<p><strong>插入图解：</strong><br>  <strong>1：插入38，此时为空树，直接插入，并作为根节点。继续插入22、76、40，符合情形（2），直接插入。继续插入51，符合情形（3），执行分裂。</strong><br><img src="https://images.xiaozhuanlan.com/photo/2019/dc033d4156cfa7da62d0c2f5a354238d.png" alt="img"><br>  <strong>2：按照相同的步骤继续插入13、21。插入39，符合情形（3），导致节点分裂。选择中值22作为父节点，并将22节点上移，与40节点进行合并。</strong><br><img src="https://images.xiaozhuanlan.com/photo/2019/b5a9e1ada99f5ee6d90254ec2972514c.png" alt="img"><br>  <strong>3：按照同样的插入规则，继续向树中插入key为30、27、33、36、35、34、24、29的数据。插入完成后，继续插入key为26的数据，插入之后需要执行节点分裂。</strong><br><img src="https://images.xiaozhuanlan.com/photo/2019/0b2fb4783a1f3a3dde1f3066dc234ba2.png" alt="img"><br>  <strong>4：将key为27的数据节点上移至父节点，此时父节点已经有4个key，插入key27的数据后需要执行节点分裂。在插入key为26的数据后，导致根节点发生分裂，树的高度加1。</strong><br><img src="https://images.xiaozhuanlan.com/photo/2019/69d81bce093055474a03f15d3a42dcfb.png" alt="img"></p>
<h2 id="4-3-性能分析"><a href="#4-3-性能分析" class="headerlink" title="4.3 性能分析"></a>4.3 性能分析</h2><p>  B树插入过程首先需要执行一次查找操作，B树的查找操作的时间复杂度为O(mlogmn)。其中m为B树的阶数，n为B树中key的数目。在插入过程，最耗时的情形即为：插入数据后导致根节点发生分裂，分裂节点的操作是常数级，分裂操作向上回溯的时间复杂度为O(h)。因此，B树的插入操作的时间复杂度近似于查找操作，即O(mlogmn)。</p>
<h1 id="5-删除"><a href="#5-删除" class="headerlink" title="5 删除"></a>5 删除</h1><h2 id="5-1-删除流程"><a href="#5-1-删除流程" class="headerlink" title="5.1 删除流程"></a>5.1 删除流程</h2><p><strong>B树的删除流程如下：</strong><br>  （1）如果当前需要删除的key位于非叶子结点上，则用后继key（这里的后继key均指后继记录的意思）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上，这个过程和二叉搜索树删除结点的方式类似。删除这个记录后执行第2步<br>  （2）该结点key个数大于等于Math.ceil(m/2)-1，结束删除操作，否则执行第（3）步。<br>  （3）如果兄弟结点key个数大于Math.ceil(m/2)-1，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复第（2）步。</p>
<h2 id="5-2-实例图解"><a href="#5-2-实例图解" class="headerlink" title="5.2 实例图解"></a>5.2 实例图解</h2><p><strong>删除图解：</strong><br>  <strong>1：首先删除21，符合情形（2）直接删除。删除21后，继续删除27，符合情形（1），使用后继节点28替代27，并删除28。</strong><br><img src="https://images.xiaozhuanlan.com/photo/2019/052d77ab4c66bd2386c298bd2ff723cf.png" alt="img"><br>  <strong>2：删除28后，当前节点只有一个key，因此需要按照情形（3）调整。当前节点的兄弟节点有3个key，父节点中key28下移，兄弟节点中key26上移，调整结束。调整完毕后继续删除32。</strong><br><img src="https://images.xiaozhuanlan.com/photo/2019/726b4e497e7e950fa0a94e336e3e78ff.png" alt="img"><br>  <strong>3：删除32后，需要按照情形（3）进行调整，当前节点的兄弟节点只有2个key，则将父节点下移，将当前节点与一个兄弟节点合并，调整完毕。继续删除39，删除39后按照情形（3）进行调整。</strong><br><img src="https://images.xiaozhuanlan.com/photo/2019/366534f447bf277b2936bea5c64e7262.png" alt="img"><br>  <strong>4：当前节点变为只含有key40的节点，需要按照情形（3）继续调整，执行节点的合并，合并操作中包含根节点，导致合并之后的树的高度减1。</strong><br><img src="https://images.xiaozhuanlan.com/photo/2019/f9c8f652f7f932620142f1489702967d.png" alt="img"></p>
<h2 id="5-3-性能分析"><a href="#5-3-性能分析" class="headerlink" title="5.3 性能分析"></a>5.3 性能分析</h2><p>  B树的删除操作同样需要执行查找过程，时间复杂度为O(mlogmn)。删除数据过程与插入过程类似，最坏情况需要回溯O(h)。因此B树的删除操作的时间复杂度近似为O(mlogmn)。</p>
<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><p>  <strong>B树是一种平衡的多路查找树。</strong>其设计思路主要是通过节点中存储不止一个key，来降低树的高度。同等比较次数下，树的高度小保证磁盘IO次数相对较少，提高查找效率。</p>
<h1 id="7-代码实现"><a href="#7-代码实现" class="headerlink" title="7 代码实现"></a>7 代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;定义B树的节点结构</span><br><span class="line">class BTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    int *keys;  &#x2F;&#x2F;存储key的数组</span><br><span class="line">    int t;      &#x2F;&#x2F;允许存储的最多key数目，即阶数</span><br><span class="line">    BTreeNode **C; &#x2F;&#x2F;存储孩子数组指针</span><br><span class="line">    int n;     &#x2F;&#x2F;存储当前key的数目</span><br><span class="line">    bool leaf; &#x2F;&#x2F;判断此节点是否为叶子节点</span><br><span class="line"> </span><br><span class="line">public:</span><br><span class="line"> </span><br><span class="line">    BTreeNode(int _t, bool _leaf);   &#x2F;&#x2F; 构造函数</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;遍历树</span><br><span class="line">    void traverse();</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;查找键值为k的节点，若查找失败返回空</span><br><span class="line">    BTreeNode *search(int k); </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;查找键值为k的索引位置</span><br><span class="line">    int findKey(int k);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;插入</span><br><span class="line">    void insertNonFull(int k);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;分裂</span><br><span class="line">    void splitChild(int i, BTreeNode *y);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;删除键值为k的数据</span><br><span class="line">    void remove(int k);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;删除叶子节点</span><br><span class="line">    void removeFromLeaf(int idx);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;删除非叶子节点</span><br><span class="line">    void removeFromNonLeaf(int idx);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;获取前驱节点</span><br><span class="line">    int getPred(int idx);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;获取后继节点</span><br><span class="line">    int getSucc(int idx);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;填充节点</span><br><span class="line">    void fill(int idx);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;向父节点借用key</span><br><span class="line">    void borrowFromPrev(int idx);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 从C[idx+1]-th节点借用一个key，并将其放在C[idx]第th节点中</span><br><span class="line">    void borrowFromNext(int idx);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;节点合并</span><br><span class="line">    void merge(int idx);</span><br><span class="line"> </span><br><span class="line">    friend class BTree;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义树结构</span><br><span class="line">class BTree</span><br><span class="line">&#123;</span><br><span class="line">    BTreeNode *root; &#x2F;&#x2F;根节点指针</span><br><span class="line">    int t;  </span><br><span class="line">public:</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 构造函数</span><br><span class="line">    BTree(int _t)</span><br><span class="line">    &#123;</span><br><span class="line">        root &#x3D; NULL;</span><br><span class="line">        t &#x3D; _t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">	&#x2F;&#x2F;遍历</span><br><span class="line">    void traverse()</span><br><span class="line">    &#123;</span><br><span class="line">        if (root !&#x3D; NULL) root-&gt;traverse();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;查找</span><br><span class="line">    BTreeNode* search(int k)</span><br><span class="line">    &#123;</span><br><span class="line">        return (root &#x3D;&#x3D; NULL)? NULL : root-&gt;search(k);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;插入</span><br><span class="line">    void insert(int k);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;删除</span><br><span class="line">    void remove(int k);</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数</span><br><span class="line">BTreeNode::BTreeNode(int t1, bool leaf1)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;定义树的阶</span><br><span class="line">    t &#x3D; t1;</span><br><span class="line">    leaf &#x3D; leaf1;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;根据树的阶数，分配数据空间</span><br><span class="line">    keys &#x3D; new int[2*t-1];</span><br><span class="line">    C &#x3D; new BTreeNode *[2*t];</span><br><span class="line">    &#x2F;&#x2F;当前key数目为0</span><br><span class="line">    n &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;查找键值为key的节点</span><br><span class="line">int BTreeNode::findKey(int k)</span><br><span class="line">&#123;</span><br><span class="line">    int idx&#x3D;0;</span><br><span class="line">    while (idx &lt; n &amp;&amp; keys[idx] &lt; k)</span><br><span class="line">        ++idx;</span><br><span class="line">    return idx;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;删除键值为k节点</span><br><span class="line">void BTreeNode::remove(int k)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;首先执行查找过程</span><br><span class="line">    int idx &#x3D; findKey(k);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;查找到节点</span><br><span class="line">    if (idx &lt; n &amp;&amp; keys[idx] &#x3D;&#x3D; k)</span><br><span class="line">    &#123;</span><br><span class="line">        if (leaf)&#x2F;&#x2F;如果是叶子节点，调用删除叶子节点的方法</span><br><span class="line">            removeFromLeaf(idx);</span><br><span class="line"></span><br><span class="line">        else &#x2F;&#x2F;如果不是叶子节点，则调用非叶子节点的删除方法</span><br><span class="line">            removeFromNonLeaf(idx);</span><br><span class="line">    &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;如果查找结束位置为叶子节点，则查找失败</span><br><span class="line">        if (leaf)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;待删除的key &#x3D;  &quot;&lt;&lt; k &lt;&lt;&quot;不存在\n&quot;;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;标记此节点，如果此节点位于</span><br><span class="line">        bool flag &#x3D; ( (idx&#x3D;&#x3D;n)? true : false );</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;如果该键存在的子节点的t键更少，则填充该子节点</span><br><span class="line">        if (C[idx]-&gt;n &lt; t)</span><br><span class="line">            fill(idx);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;如果最后一个子节点已经合并，那么它必须与前一个子节点合并，</span><br><span class="line">		&#x2F;&#x2F;因此我们对(idx-1)第1个子节点进行递归。否则，我们递归到第(idx)个子节点上</span><br><span class="line">        if (flag &amp;&amp; idx &gt; n)</span><br><span class="line">            C[idx-1]-&gt;remove(k);</span><br><span class="line">        else</span><br><span class="line">            C[idx]-&gt;remove(k);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;删除叶子节点</span><br><span class="line">void BTreeNode::removeFromLeaf (int idx)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;将idx-th之后的所有键向后移动一个位置</span><br><span class="line">    for (int i&#x3D;idx+1; i&lt;n; ++i)</span><br><span class="line">        keys[i-1] &#x3D; keys[i];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;减少key的数目</span><br><span class="line">    n--;</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;删除非叶子节点</span><br><span class="line">void BTreeNode::removeFromNonLeaf(int idx)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    int k &#x3D; keys[idx];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;如果k (C[idx])之前的子元素至少有t个键，那么在位于C[idx]的子树中找到k的前驱节点</span><br><span class="line">	&#x2F;&#x2F;用前驱代替k。在递归删除前驱节点</span><br><span class="line">    if (C[idx]-&gt;n &gt;&#x3D; t)</span><br><span class="line">    &#123;</span><br><span class="line">        int pred &#x3D; getPred(idx);</span><br><span class="line">        keys[idx] &#x3D; pred;</span><br><span class="line">        C[idx]-&gt;remove(pred);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;如果子C[idx]的键值数目小于t，则检查C[idx+1]。如果C[idx+1]中至少有t个键，则查找k的后继节点</span><br><span class="line">	&#x2F;&#x2F;使用后继节点替换k，递归删除后继节点</span><br><span class="line">    else if  (C[idx+1]-&gt;n &gt;&#x3D; t)</span><br><span class="line">    &#123;</span><br><span class="line">        int succ &#x3D; getSucc(idx);</span><br><span class="line">        keys[idx] &#x3D; succ;</span><br><span class="line">        C[idx+1]-&gt;remove(succ);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 如果C[idx]和C[idx+1]键值数目均少于t，则合并k和C[idx+1]至C[idx]</span><br><span class="line">    &#x2F;&#x2F; 合并后C[idx]包含2t-1个key，删除C[idx+1]，然后在C[idx]中递归删除后继节点</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        merge(idx);</span><br><span class="line">        C[idx]-&gt;remove(k);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;获取前驱节点</span><br><span class="line">int BTreeNode::getPred(int idx)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;一直向最右子树移动，直到到达叶子节点</span><br><span class="line">    BTreeNode *cur&#x3D;C[idx];</span><br><span class="line">    while (!cur-&gt;leaf)</span><br><span class="line">        cur &#x3D; cur-&gt;C[cur-&gt;n];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;返回前驱节点</span><br><span class="line">    return cur-&gt;keys[cur-&gt;n-1];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取后继节点</span><br><span class="line">int BTreeNode::getSucc(int idx)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;一直向最左的子树移动，直至到达叶子节点</span><br><span class="line">    BTreeNode *cur &#x3D; C[idx+1];</span><br><span class="line">    while (!cur-&gt;leaf)</span><br><span class="line">        cur &#x3D; cur-&gt;C[0];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;返回后继节点</span><br><span class="line">    return cur-&gt;keys[0];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;一个用来填充子C[idx]的函数，它的键值小于t-1</span><br><span class="line">void BTreeNode::fill(int idx)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;如果前一个子节点(C[idx-1])具有多于t-1的键，则从该子节点借用一个键</span><br><span class="line">    if (idx!&#x3D;0 &amp;&amp; C[idx-1]-&gt;n&gt;&#x3D;t)</span><br><span class="line">        borrowFromPrev(idx);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;如果下一个子节点(C[idx+1])的键数大于t-1，则从该子节点借用一个键</span><br><span class="line">    else if (idx!&#x3D;n &amp;&amp; C[idx+1]-&gt;n&gt;&#x3D;t)</span><br><span class="line">        borrowFromNext(idx);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;如果C[idx]是最后一个子元素，则将它与前一个子元素合并，否则将它与下一个子元素合并</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if (idx !&#x3D; n)</span><br><span class="line">            merge(idx);</span><br><span class="line">        else</span><br><span class="line">            merge(idx-1);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;从前一个子节点(C[idx-1])借用一个键</span><br><span class="line">void BTreeNode::borrowFromPrev(int idx)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    BTreeNode *child&#x3D;C[idx];</span><br><span class="line">    BTreeNode *sibling&#x3D;C[idx-1];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;C[idx-1]中的最后一个键向上到达父键，并将父键[idx-1]作为C[idx]中的第一个键插入。</span><br><span class="line">    &#x2F;&#x2F;将C[idx]中的所有键向前移动一步</span><br><span class="line">    for (int i&#x3D;child-&gt;n-1; i&gt;&#x3D;0; --i)</span><br><span class="line">        child-&gt;keys[i+1] &#x3D; child-&gt;keys[i];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;如果C[idx]不是叶子节点，则将其所有子指针向前移动一步</span><br><span class="line">    if (!child-&gt;leaf)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;child-&gt;n; i&gt;&#x3D;0; --i)</span><br><span class="line">            child-&gt;C[i+1] &#x3D; child-&gt;C[i];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;将子节点的第一个键设置为当前节点的键[idx-1]</span><br><span class="line">    child-&gt;keys[0] &#x3D; keys[idx-1];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;将兄弟节点的最后一个孩子移动为C[idx]的第一个孩子</span><br><span class="line">    if (!leaf)</span><br><span class="line">        child-&gt;C[0] &#x3D; sibling-&gt;C[sibling-&gt;n];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;将键从同级键移到父级键，这会减少同级键的数量</span><br><span class="line">    keys[idx-1] &#x3D; sibling-&gt;keys[sibling-&gt;n-1];</span><br><span class="line"> </span><br><span class="line">    child-&gt;n +&#x3D; 1;</span><br><span class="line">    sibling-&gt;n -&#x3D; 1;</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;从后继节点借用一个键</span><br><span class="line">void BTreeNode::borrowFromNext(int idx)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    BTreeNode *child&#x3D;C[idx];</span><br><span class="line">    BTreeNode *sibling&#x3D;C[idx+1];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;键[idx]作为C[idx]中的最后一个键插入</span><br><span class="line">    child-&gt;keys[(child-&gt;n)] &#x3D; keys[idx];</span><br><span class="line"> </span><br><span class="line">	&#x2F;&#x2F;将兄弟节点的第一个子元素作为最后一个子元素插入到C[idx]中</span><br><span class="line">    if (!(child-&gt;leaf))</span><br><span class="line">        child-&gt;C[(child-&gt;n)+1] &#x3D; sibling-&gt;C[0];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;将兄弟节点中的第一个键插入至[idx]</span><br><span class="line">    keys[idx] &#x3D; sibling-&gt;keys[0];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;将兄弟节点中的所有键向后移动一步</span><br><span class="line">    for (int i&#x3D;1; i&lt;sibling-&gt;n; ++i)</span><br><span class="line">        sibling-&gt;keys[i-1] &#x3D; sibling-&gt;keys[i];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;将子指针向后移动一步</span><br><span class="line">    if (!sibling-&gt;leaf)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;1; i&lt;&#x3D;sibling-&gt;n; ++i)</span><br><span class="line">            sibling-&gt;C[i-1] &#x3D; sibling-&gt;C[i];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    child-&gt;n +&#x3D; 1;</span><br><span class="line">    sibling-&gt;n -&#x3D; 1;</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;合并</span><br><span class="line">void BTreeNode::merge(int idx)</span><br><span class="line">&#123;</span><br><span class="line">    BTreeNode *child &#x3D; C[idx];</span><br><span class="line">    BTreeNode *sibling &#x3D; C[idx+1];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;从当前节点中取出出一个key，插入到C[idx]的(t-1)位置</span><br><span class="line">    child-&gt;keys[t-1] &#x3D; keys[idx];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;将key从C[idx+1]复制到最后的C[idx]</span><br><span class="line">    for (int i&#x3D;0; i&lt;sibling-&gt;n; ++i)</span><br><span class="line">        child-&gt;keys[i+t] &#x3D; sibling-&gt;keys[i];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;将孩子指针从C[idx+1]复制到C[idx]</span><br><span class="line">    if (!child-&gt;leaf)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;&#x3D;sibling-&gt;n; ++i)</span><br><span class="line">            child-&gt;C[i+t] &#x3D; sibling-&gt;C[i];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;将当前节点中的所有键在idx之后移动一步，以填补将键[idx]移动到C[idx]所造成的空白。</span><br><span class="line">    for (i &#x3D; idx+1; i&lt;n; ++i)</span><br><span class="line">        keys[i-1] &#x3D; keys[i];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;将子指针移动到当前节点(idx+1)的后面</span><br><span class="line">    for (i&#x3D;idx+2; i&lt;&#x3D;n; ++i)</span><br><span class="line">        C[i-1] &#x3D; C[i];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 更新数据值</span><br><span class="line">    child-&gt;n +&#x3D; sibling-&gt;n+1;</span><br><span class="line">    n--;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;删除兄弟节点</span><br><span class="line">    delete(sibling);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;插入</span><br><span class="line">void BTree::insert(int k)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;树为空</span><br><span class="line">    if (root &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;直接作为根节点插入</span><br><span class="line">        root &#x3D; new BTreeNode(t, true);</span><br><span class="line">        root-&gt;keys[0] &#x3D; k;  </span><br><span class="line">        root-&gt;n &#x3D; 1; </span><br><span class="line">    &#125;</span><br><span class="line">    else &#x2F;&#x2F;树不为空</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;判断树是否已满</span><br><span class="line">        if (root-&gt;n &#x3D;&#x3D; 2*t-1)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;树已满则重新创建根节点</span><br><span class="line">            BTreeNode *s &#x3D; new BTreeNode(t, false);</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;将原树根节点作为新树子节点</span><br><span class="line">            s-&gt;C[0] &#x3D; root;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;分裂子节点</span><br><span class="line">            s-&gt;splitChild(0, root);</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; 新的根节点有两个孩子</span><br><span class="line">            int i &#x3D; 0;</span><br><span class="line">            if (s-&gt;keys[0] &lt; k)</span><br><span class="line">                i++;</span><br><span class="line">            s-&gt;C[i]-&gt;insertNonFull(k);</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;改变根节点</span><br><span class="line">            root &#x3D; s;</span><br><span class="line">        &#125;</span><br><span class="line">        else  &#x2F;&#x2F;树不为空，插入k</span><br><span class="line">            root-&gt;insertNonFull(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;插入k</span><br><span class="line">void BTreeNode::insertNonFull(int k)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; n-1;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 插入位置为叶子节点</span><br><span class="line">    if (leaf &#x3D;&#x3D; true)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;查找要插入的新键的位置，将所有较大的键移动到前面的一个位置</span><br><span class="line">        while (i &gt;&#x3D; 0 &amp;&amp; keys[i] &gt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            keys[i+1] &#x3D; keys[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;插入数据</span><br><span class="line">        keys[i+1] &#x3D; k;</span><br><span class="line">        n &#x3D; n+1;&#x2F;&#x2F;更新key的数目</span><br><span class="line">    &#125;</span><br><span class="line">    else &#x2F;&#x2F;插入位置部位叶子节点</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 查找插入位置</span><br><span class="line">        while (i &gt;&#x3D; 0 &amp;&amp; keys[i] &gt; k)</span><br><span class="line">            i--;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 插入位置的节点是否已满</span><br><span class="line">        if (C[i+1]-&gt;n &#x3D;&#x3D; 2*t-1)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;如果已满，则执行分裂</span><br><span class="line">            splitChild(i+1, C[i+1]);</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;分裂后在决定那个孩子插入此key</span><br><span class="line">            if (keys[i+1] &lt; k)</span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">		&#x2F;&#x2F;递归调用插入k</span><br><span class="line">        C[i+1]-&gt;insertNonFull(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;子节点分裂</span><br><span class="line">void BTreeNode::splitChild(int i, BTreeNode *y)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;创建新的父节点</span><br><span class="line">    BTreeNode *z &#x3D; new BTreeNode(y-&gt;t, y-&gt;leaf);</span><br><span class="line">	&#x2F;&#x2F;新节点的key数目为t-1</span><br><span class="line">    z-&gt;n &#x3D; t - 1;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;将y中的后(t-1)key复制到z</span><br><span class="line">    for (int j &#x3D; 0; j &lt; t-1; j++)</span><br><span class="line">        z-&gt;keys[j] &#x3D; y-&gt;keys[j+t];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Copy the last t children of y to z</span><br><span class="line">    if (y-&gt;leaf &#x3D;&#x3D; false)</span><br><span class="line">    &#123;</span><br><span class="line">        for (j &#x3D; 0; j &lt; t; j++)</span><br><span class="line">            z-&gt;C[j] &#x3D; y-&gt;C[j+t];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;减少y中键的数量</span><br><span class="line">    y-&gt;n &#x3D; t - 1;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;创建新子节点的空间</span><br><span class="line">    for ( j &#x3D; n; j &gt;&#x3D; i+1; j--)</span><br><span class="line">        C[j+1] &#x3D; C[j];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 将新子节点链接到此节点</span><br><span class="line">    C[i+1] &#x3D; z;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;重新查找key位置</span><br><span class="line">    for ( j &#x3D; n-1; j &gt;&#x3D; i; j--)</span><br><span class="line">        keys[j+1] &#x3D; keys[j];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 将y的中间键值复制到此节点</span><br><span class="line">    keys[i] &#x3D; y-&gt;keys[t-1];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 增加节点数目</span><br><span class="line">    n &#x3D; n + 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;遍历树</span><br><span class="line">void BTreeNode::traverse()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    int i;</span><br><span class="line">    for (i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (leaf &#x3D;&#x3D; false)</span><br><span class="line">            C[i]-&gt;traverse();</span><br><span class="line">        cout &lt;&lt; &quot; &quot; &lt;&lt; keys[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if (leaf &#x3D;&#x3D; false)</span><br><span class="line">        C[i]-&gt;traverse();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;查找</span><br><span class="line">BTreeNode *BTreeNode::search(int k)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 找到第一个大于等于k的键</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    while (i &lt; n &amp;&amp; k &gt; keys[i])</span><br><span class="line">        i++;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 查找成功</span><br><span class="line">    if (keys[i] &#x3D;&#x3D; k)</span><br><span class="line">        return this;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 到达叶子节点，查找失败</span><br><span class="line">    if (leaf &#x3D;&#x3D; true)</span><br><span class="line">        return NULL;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 递归</span><br><span class="line">    return C[i]-&gt;search(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除</span><br><span class="line">void BTree::remove(int k)</span><br><span class="line">&#123;</span><br><span class="line">    if (!root)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;The tree is empty\n&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    root-&gt;remove(k);</span><br><span class="line"></span><br><span class="line">    if (root-&gt;n&#x3D;&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        BTreeNode *tmp &#x3D; root;</span><br><span class="line">        if (root-&gt;leaf)</span><br><span class="line">            root &#x3D; NULL;</span><br><span class="line">        else</span><br><span class="line">            root &#x3D; root-&gt;C[0];</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;释放节点空间</span><br><span class="line">        delete tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;测试程序</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    BTree t(3); &#x2F;&#x2F;创建阶为4的B树，最多允许有3个key</span><br><span class="line"> </span><br><span class="line">    t.insert(1);</span><br><span class="line">    t.insert(3);</span><br><span class="line">    t.insert(7);</span><br><span class="line">    t.insert(10);</span><br><span class="line">    t.insert(11);</span><br><span class="line">    t.insert(13);</span><br><span class="line">    t.insert(14);</span><br><span class="line">    t.insert(17);</span><br><span class="line">    t.insert(18);</span><br><span class="line">    t.insert(16);</span><br><span class="line">    t.insert(19);</span><br><span class="line">    t.insert(24);</span><br><span class="line">    t.insert(25);</span><br><span class="line">    t.insert(29);</span><br><span class="line">    t.insert(21);</span><br><span class="line">    t.insert(4);</span><br><span class="line">    t.insert(5);</span><br><span class="line">    t.insert(20);</span><br><span class="line">    t.insert(22);</span><br><span class="line">    t.insert(2);</span><br><span class="line">    t.insert(17);</span><br><span class="line">    t.insert(12);</span><br><span class="line">    t.insert(6);</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; &quot;Traversal of tree constructed is\n&quot;;</span><br><span class="line">    t.traverse();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    t.remove(6);</span><br><span class="line">    cout &lt;&lt; &quot;Traversal of tree after removing 6\n&quot;;</span><br><span class="line">    t.traverse();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    t.remove(13);</span><br><span class="line">    cout &lt;&lt; &quot;Traversal of tree after removing 13\n&quot;;</span><br><span class="line">    t.traverse();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    t.remove(7);</span><br><span class="line">    cout &lt;&lt; &quot;Traversal of tree after removing 7\n&quot;;</span><br><span class="line">    t.traverse();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    t.remove(4);</span><br><span class="line">    cout &lt;&lt; &quot;Traversal of tree after removing 4\n&quot;;</span><br><span class="line">    t.traverse();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    t.remove(2);</span><br><span class="line">    cout &lt;&lt; &quot;Traversal of tree after removing 2\n&quot;;</span><br><span class="line">    t.traverse();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    t.remove(16);</span><br><span class="line">    cout &lt;&lt; &quot;Traversal of tree after removing 16\n&quot;;</span><br><span class="line">    t.traverse();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </div>
  
  <div class="article-tags">
    
      <a class="tag-none-link" href="/tags/%E6%A0%91%E8%AE%BA%E5%92%8C%E5%9B%BE%E8%AE%BA/" rel="tag">树论和图论</a>
    
  </div>

  
  <section id="comments" class="white-box">
    
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
    
	</section>
	

</article>

      <script>document.getElementById("loading-bar").style.width="60%";</script>
    </main>
    
<footer id="footer" class="clearfix">
	
	<div class="search">
	  <form name="searchform" id="searchform" class="u-search-form">
	    <input type="text" id="searchinput" 
				class="u-search-input st-default-search-input"
				data-list-highlight="true" 
				data-list-value-completion="true" 
				placeholder="Looking for something?" />
	    <button type="submit" id="u-search-btn-submit" class="u-search-btn-submit">
	      <span class="icon icon-search"></span>
	    </button>
	  </form>
	</div>
	
  <div>&copy; <a href="http://example.com">Molu</a> Theme by <a href="http://artifact.me/" target="_blank">Art Chen</a>.</div>
  <div>Powered by <a target="_blank" href="https://hexo.io/" rel="external noopener">Hexo</a>.</div>
</footer>


    <script>document.getElementById("loading-bar").style.width="80%";</script>
    <div class="overlay"></div>
  </div>
  <div class="site-sidebar">

	
	
	<div class="sidebar-switch clearfix "
		style="display: none">
		<a class="dark-btn active" data-toggle="toc">
	    <span class="icon icon-list"></span>
	    <span class="text">Index</span>
	  </a>
	  <a class="dark-btn" data-toggle="bio">
	    <span class="icon icon-person"></span>
	    <span class="text">Bio</span>
	  </a>
	</div>

	<div class="site-toc "
		style="display: none">
		
	    <div class="no-index">No Index</div>
	  
  </div>
  
	<div class="site-bio show"
		style="display: block">
		
	  <!-- About Me -->
	  <div class="about-me clearfix">
	    <div class="avatar">
	      <img src="/img/avatar.png" />
	    </div>
	    <div class="info">
	      <a class="name dark-btn" href="/about">
	        Rick Smith
	      </a>
	    </div>
	    <div class="info">
	      <span class="item desc">
	        
	      </span>
	    </div>
	  </div>
	
	  <!-- Social Icons -->
	  <div class="social clearfix">
	    
	      
	        <a href="/atom.xml" class="feed"
	          target="_blank" rel="external">
	          <span class="icon icon-feed"></span>
	        </a>
	      
	        <a href="https://github.com/artchen" class="github"
	          target="_blank" rel="external">
	          <span class="icon icon-github"></span>
	        </a>
	      
	    
	  </div>

	</div>

	<div class="shortcuts">
		<a href="#header" class="top window-nav dark-btn" id="go-top">
			<span class="icon icon-chevron-thin-up"></span>
		</a>
		<a class="close dark-btn" id="sidebar-close">
			<span class="icon icon-close"></span>
		</a>
		<a href="#footer" class="top window-nav dark-btn" id="go-bottom">
			<span class="icon icon-chevron-thin-down"></span>
		</a>
	</div>

</div>

  <!-- Universal Search -->

<script type="text/javascript">
  var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
  var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
  var ALGOLIA_API_KEY = "";
  var ALGOLIA_APP_ID = "";
  var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
  var universalSearchConfig = {};
  if (SEARCH_SERVICE === 'google') {
    universalSearchConfig = {
      searchService: SEARCH_SERVICE,
      apiKey: GOOGLE_CUSTOM_SEARCH_API_KEY,
      engineId: GOOGLE_CUSTOM_SEARCH_ENGINE_ID,
      imagePath: "/img/"
    };
  } else if (SEARCH_SERVICE === 'algolia') {
    universalSearchConfig = {
      searchService: SEARCH_SERVICE,
      apiKey: ALGOLIA_API_KEY,
      appId: ALGOLIA_APP_ID,
      indexName: ALGOLIA_INDEX_NAME,
      imagePath: "/img/"
    };
  } else if (SEARCH_SERVICE === 'azure') {
    universalSearchConfig = {
      searchService: SEARCH_SERVICE,
      serviceName: AZURE_SERVICE_NAME,
      indexName: AZURE_INDEX_NAME,
      apiKey: AZURE_QUERY_KEY,
      imagePath: "/img/"
    };
  }
</script>

<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.js"><\/script>')</script>


<script src="/js/search.js"></script>


<script src="/js/app.js"></script>


<!-- Disqus -->


<script type="text/javascript">
  var disqus_shortname = 'molu';
  
  var disqus_url = 'http://example.com/2019/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-B%E6%A0%91%EF%BC%88B-%E6%A0%91%EF%BC%89/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<!-- Valine -->


<!-- Swiftype -->
<!-- Please replace with your own swiftype settings -->
<!--
<script type="text/javascript">
  /* Swiftype */
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','FHMeAyBdVccJECstf-XJ','2.0.0');
</script>
-->

  <script>document.getElementById("loading-bar").style.width="100%";</script>
</body>
</html>
